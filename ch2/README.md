## 命名

1. Go 语言中类似 if 和 switch 的关键字有 25 个；关键字不能用于自定义名字，只能在特定语法结构中使用。

```
break      default       func     interface   select
case       defer         go       map         struct
chan       else          goto     package     switch
const      fallthrough   if       range       type
continue   for           import   return      var
```

此外，还有大约 30 多个预定义的名字，比如 int 和 true 等，主要对应内建的常量、类型和函数。

```
内建常量: true false iota nil

内建类型: int int8 int16 int32 int64
          uint uint8 uint16 uint32 uint64 uintptr
          float32 float64 complex128 complex64
          bool byte rune string error

内建函数: make len cap new append copy close delete
          complex real imag
          panic recover
```

> 如果一个名字是在函数内部定义，那么它的就只在函数内部有效。如果是在函数外部定义，那么将在当前包的所有文件中都可以访问。
> 名字的开头字母的大小写决定了名字在包外的可见性:如果一个名字是大写字母开头的（译注：必须是在函数外部定义的包级名字；包级函数名本身也是包级名字），那么它将是导出的，也就是说可以被外部的包访问，例如 fmt 包的 Printf 函数就是导出的，可以在 fmt 包外部访问。包本身的名字一般总是用小写字母。

## 声明

> 定义了程序的各种实体对象以及部分或全部的属性. Go 语言主要有四种类型的声明语句：var、const、type 和 func，分别对应变量、常量、类型和函数实体对象的声明

## 变量

0. var 声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始值。
   > Go 语言中不存在未初始化的变量: 如果初始化表达式被省略，那么将用零值初始化该变量。 数值类型变量对应的零值是 0，布尔类型变量对应的零值是 false，字符串类型对应的零值是空字符串，接口或引用类型（包括 slice、指针、map、chan 和函数）变量对应的零值是 nil。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。

```
var 变量名字 类型 = 表达式 //“类型”或“= 表达式”两个部分可以省略其中的一个
```

1. 简短变量声明

> 在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“名字 := 表达式”形式声明变量，变量的类型根据表达式来自动推导。
> 和普通 var 形式的变量声明语句一样，简短变量声明语句也可以用函数的返回值来声明和初始化变量.简短变量声明语句中必须至少要声明一个新的变量，下面的代码将不能编译通过

```
f, err := os.Open(infile)
// ...
f, err := os.Create(outfile) // compile error: no new variables
```

2. 指针

> 一个变量对应一个保存了变量对应类型值的内存空间。一个指针的值是另一个变量的地址。一个指针对应变量在内存中的存储位置。并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址。任何类型的指针的零值都是 nil。

3. new 函数

> `new(T)`将创建一个 T 类型的匿名变量，初始化为 T 类型的零值，然后返回变量地址，返回的指针类型为`*T`

4. 变量的生命周期

## 赋值

1. 变量赋值

```
x = 1                       // 命名变量的赋值
*p = true                   // 通过指针间接赋值
person.name = "bob"         // 结构体字段赋值
count[x] = count[x] * scale // count[x] *= scale // 数组、slice或map的元素赋值

v := 1 //数值变量也可以支持++递增和--递减语句.但不支持表达式 x=i++
v++    // 等价方式 v = v + 1；v 变成 2
v--    // 等价方式 v = v - 1；v 变成 1
```

2. 元组赋值
   > 允许同时更新多个变量的值

```
x, y = y, x

a[i], a[j] = a[j], a[i]

func gcd(x, y int) int {
    for y != 0 {
        x, y = y, x%y
    }
    return x
}

func fib(n int) int {
    x, y := 0, 1
    for i := 0; i < n; i++ {
        x, y = y, x+y
    }
    return x
}
<!-- 使一系列琐碎赋值更加紧凑 -->
i, j, k = 2, 3, 5
<!-- 左边变量的数目必须和右边一致 -->
f, err = os.Open("foo.txt") // function call returns two values


v, ok = m[key]             // map lookup
v, ok = x.(T)              // type assertion
v, ok = <-ch               // channel receive
_, ok = x.(T)              // 只检测类型，忽略具体值
```

2. 可赋值性

> 赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为：函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回语句会隐式地将返回操作的值赋值给结果变量，一个复合类型的字面量（§4.2）也会产生赋值行为。

不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。对于两个值是否可以用==或!=进行相等比较的能力也和可赋值能力有关系:对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的，反之亦然。

## 类型

> 变量或表达式的类型定义了对应存储值的属性特征

一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。

```
type 类型名字 底层类型
```

## 包和文件

> Go 语言中的包和其他语言的库或模块的概念类似，目的都是为了支持模块化、封装、单独编译和代码重用.在 Go 语言中，一个简单的规则是：如果一个名字是大写字母开头的，那么该名字是导出的（译注：因为汉字不区分大小写，因此汉字开头的名字是没有导出的）。
